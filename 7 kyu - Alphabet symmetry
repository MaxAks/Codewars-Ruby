def solve(arr)
#...
voc_id = ("a".."z").to_a # массив с элементами букв для сравнения с элементом из исходного массива
arr_fin = [] # финальный массив содержащий в себе количество букв на нужно месте
arr_time = [] # промежуточный массив в котором будут содержаться разбитые на буквы каждый элемент массива arr
count = 0 # счетсчик совпадений позиций и элементов массива voc_id и arr_time
arr.each do |x|
arr_time = x.downcase.split(//) # берется каждый элемент массива arr, затем downcase - делает все буквы маленькие, затем split(//) 
# разбивает весь элемент на буквы. Полученные отдельные буквы записываются в промежуточный массив arr_time
arr_time.each_with_index do |name, index| # используем значения элемента массива и его индекс
arr_time[index] == voc_id[index] ? count =count +1 : count = count
=begin
Используем тернарный оператор
arr_time[index] если текущий взятый элемент временного массива равен
voc_id[index] элементу из массива сравнения 
если условие выполняется, то счетчик совпадений увеличивается
=end
end

arr_fin.push(count) # В финальный массив вносится количество совпадений во временном массив arr_time
# (который равен одному из элементов постоянного массива arr)
count = 0 # обнуляем значения счетчика после прохождения каждого элемента основго массива arr
end
return arr_fin
end
# ЭТУ ЗАДАЧУ МОЖНО РЕШИТЬ ЧЕРЕЗ MAP , ZIP и COUNT
