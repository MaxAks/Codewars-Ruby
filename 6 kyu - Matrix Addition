# ПЕРВОЕ РЕШЕНИЕ
# def matrixAddition(a, b) убрал для метода
=begin
условия для решени
a =  [ [1, 2],
    [1, 2] ]
#     
b =  [ [2, 3],
    [2, 3] ] 
=end   
    
c = a.flatten

=begin
flatten - Возвращает новый массив, который представляет собой одномерное выравнивание себя (рекурсивно). Условно раскрывает подуровни 
вложенных массивов в простой массив
ПОДРОБНЕЕ ЗДЕСЬ https://apidock.com/ruby/Array/flatten
=end

d = b.flatten
e = c.map{|i| d.shift.to_i + i }

=begin
map - Возвращает новый массив с результатами однократного запуска блока для каждого элемента в перечислении. ИНЫМИ словами совершает с 
каждым блоком массива одну операцию, которую указываем для выполнения. В данном случае это d.shift.to_i + i
map - ПОДРОБНЕЕ ЗДЕСЬ https://apidock.com/ruby/Enumerable/map
shift - Возвращает значение первого элемента (нескольких элементов, если указать их в скобках) при этом удаляет первый элемент (несколько) из массива и
сдвигая все остальные элементы на единицу вниз(влево). Возвращает nil , если массив пуст. 
shift - ПОДРОБНЕЕ ЗДЕСЬ https://apidock.com/ruby/Array/shift
=end

print e.each_slice(a.size).to_a # to_a для того чтобы избежать ошибки #<Enumerator: [3, 5, 3, 5]:each_slice(2)>
# для метода заменить print на return
=begin
each_slice - разбивает массив на блоки исходя из указанного размера блока. ВОЗВРАЩАЕТ nil !!!
each_slice выполняет для каждого слайса блок, но ничего не возвращает, так и должно быть!!!
поэтому после него надо ставить добавление в массив или передавать дальнешему оператору - присваемаещему значение
each_slice - ПОДРОБНЕЕ ЗДЕСЬ https://apidock.com/ruby/Enumerable/each_slice
=end

#end - убрал для метода

# МОЖНО решить через матрицы, изначально и хотел через них
